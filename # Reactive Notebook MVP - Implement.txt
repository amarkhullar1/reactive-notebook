# Reactive Notebook MVP - Implementation Plan

**Goal:** Build a minimal viable reactive notebook where editing a cell automatically re-runs dependent cells. Single user, text-only outputs, no authentication.

## Core Requirements

### Cell Management
- **Add new cells** - Button or keyboard shortcut to create new cells
- **Edit cell code** - Text editor/textarea (Monaco Editor) for code input
- **Delete cells** - Ability to remove cells from the notebook
- **Display code and output** - Each cell shows its code editor and output area
- **Generate output on execution** - Running a cell generates its output (or error message)

### Visual Feedback
- **Execution status indicators** - Visual states: `idle` | `running` | `success` | `error`
  - Show loading/running state for cells being executed
  - Color-coded or icon-based status display
- **Display cell outputs** - Show text, numbers, DataFrames (as text), and errors
  - Output appears below each cell's code editor
  - Errors displayed in red or distinct error styling
  - Update outputs live as cells complete execution

### Reactive Updates
- **Automatic downstream execution** - When user runs/edits an upstream cell, trigger downstream execution
  - No manual "run" buttons needed (though optional for explicit control)
  - Cells automatically re-execute when their dependencies change
- **Execution trigger strategy** - Use debouncing to avoid excessive re-runs:
  - Wait 500-1000ms after user stops typing before triggering execution
  - OR trigger on explicit action (Shift+Enter, blur, or run button)
  - Frontend implements debounce; backend executes immediately on receiving message
- **Live output updates** - Outputs update in real-time as cells complete
- **Execution queue visibility** - Show which cells are queued for execution (optional)

## Keep in Mind

- **Technology Stack**: Must use Python and/or TypeScript
  - Backend: Python with FastAPI
  - Frontend: TypeScript with React
- **Quality Standards**: The app must be free of significant flaws including:
  - Crashes and exceptions
  - UI glitches and state inconsistencies
  - Incorrect business logic (dependency detection, execution order)
  - Race conditions in reactive updates
  - Memory leaks or resource issues

## Architecture: Simplified Stack

### Frontend (TypeScript + React)
- **Code Editor**: Monaco Editor (lightweight, good Python syntax highlighting)
- **Communication**: Native WebSocket API (no socket.io needed for MVP)
- **State**: React useState/useReducer (no Redux needed)
- **UI**: Plain CSS or Tailwind (keep it simple)

### Backend (Python + FastAPI)
- **Web Framework**: FastAPI (async WebSocket support built-in)
- **Code Execution**: Direct `exec()` in shared Python namespace (no containers for MVP)
- **Dependency Detection**: Python `ast` module for static analysis
- **Storage**: Local JSON file for notebook persistence (no database)

### Deployment
- **Development**: Run frontend (Vite on port 5173) and backend (FastAPI on port 8000) separately
- **Production**: FastAPI serves built React static files from a single process on port 8000
- Run locally, no Docker, no cloud, no load balancing

---

## Core Components

### 1. Dependency Detection Engine

**Purpose:** Analyze Python code to identify which variables are defined and used in each cell.

**Implementation:**
```python
import ast

class DependencyAnalyzer:
    def get_defined_vars(code: str) -> set[str]:
        # Parse code, find all assignment targets
        # Return set of variable names defined
        pass
    
    def get_used_vars(code: str) -> set[str]:
        # Parse code, find all Name nodes that are loaded
        # Return set of variable names referenced
        pass
    
    def build_dependency_graph(cells: list) -> dict:
        # For each cell, determine which cells it depends on
        # Return adjacency list representation
        pass
```

**Key Logic:**
- Cell B depends on Cell A if B uses any variable that A defines
- Use `ast.walk()` to traverse the Abstract Syntax Tree
- Track `ast.Assign`, `ast.AugAssign`, `ast.AnnAssign` for definitions
- Track `ast.Name` with `ast.Load` context for variable usage

**Edge Cases:**
- Ignore built-ins and imports
- Handle function/class definitions as single "variables"
- Skip variables that start with `_` (internal)
- **Syntax errors**: If `ast.parse()` fails, return empty sets and let execution handle the error
- **Dependency graph rebuild**: Rebuild graph after every cell update (code changes may alter defined/used vars)

---

### 2. Code Execution Engine

**Purpose:** Execute Python code and capture text output, including the last expression value (like Jupyter).

**Implementation:**
```python
import ast
import sys
from io import StringIO
from contextlib import redirect_stdout, redirect_stderr

class NotebookKernel:
    def __init__(self):
        self.namespace = {}  # Shared namespace for all cells
        self.cell_outputs = {}  # Store outputs per cell
    
    def execute_cell(self, cell_id: str, code: str) -> dict:
        stdout_capture = StringIO()
        stderr_capture = StringIO()
        result_value = None
        
        try:
            with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                # Split code: exec all but last expression, eval last expression for display
                tree = ast.parse(code)
                if tree.body and isinstance(tree.body[-1], ast.Expr):
                    # Last statement is an expression - eval it to capture value
                    last_expr = ast.Expression(tree.body[-1].value)
                    exec(compile(ast.Module(body=tree.body[:-1], type_ignores=[]), '<cell>', 'exec'), self.namespace)
                    result_value = eval(compile(last_expr, '<cell>', 'eval'), self.namespace)
                else:
                    exec(code, self.namespace)
            
            # Build output: stdout + repr of last expression (if any)
            output = stdout_capture.getvalue()
            if result_value is not None:
                output += repr(result_value) if not output.endswith('\n') or not output else '\n' + repr(result_value)
            
            return {
                "status": "success",
                "output": output.strip(),
                "error": stderr_capture.getvalue()
            }
        except Exception as e:
            return {
                "status": "error",
                "output": stdout_capture.getvalue(),
                "error": str(e)
            }
```

**Features:**
- Single shared `namespace` dict keeps variables alive between cell executions
- Capture both stdout (print statements) and stderr (warnings/errors)
- **Capture last expression value** - Like Jupyter, displays the repr() of the last expression (for DataFrames, variables, etc.) without needing explicit `print()`
- Return structured result with status, output, and errors

**Limitations for MVP:**
- No timeout handling (cell can run forever)
- No resource limits (can consume all memory)
- No async support (blocking execution)

---

### 3. Reactive Re-execution Logic

**Purpose:** When a cell is edited or run, automatically determine which downstream cells need to be re-executed and run them in order. No manual "run" buttons needed (though optional for explicit control).

**Key Requirements:**
- Automatic downstream execution when upstream cell changes
- Show loading/running state for cells being executed
- Update outputs live as cells complete
- Maintain correct execution order (dependencies before dependents)

**Algorithm:**
```python
class ReactiveEngine:
    def __init__(self):
        self.cells = {}  # cell_id -> Cell
        self.kernel = NotebookKernel()
        self.analyzer = DependencyAnalyzer()
        self.dep_graph = {}  # Rebuilt on every cell change
    
    def on_cell_changed(self, changed_cell_id: str, new_code: str):
        # 0. Update cell code
        self.cells[changed_cell_id].code = new_code
        
        # 1. REBUILD dependency graph (code changed, so deps may have changed)
        self.dep_graph = self.analyzer.build_dependency_graph(list(self.cells.values()))
        
        # 2. Check for circular dependencies
        if self.has_cycle():
            self.send_error_to_frontend(changed_cell_id, "Circular dependency detected")
            return
        
        # 3. Mark changed cell as "dirty"
        dirty_cells = {changed_cell_id}
        
        # 4. Find all cells that depend on this cell (directly or transitively)
        affected_cells = self.find_downstream_cells(changed_cell_id)
        dirty_cells.update(affected_cells)
        
        # 5. Topologically sort dirty cells to get execution order
        execution_order = self.topological_sort(dirty_cells)
        
        # 6. Notify frontend of execution queue
        self.send_execution_queue(execution_order)
        
        # 7. Execute cells in order, sending results as they complete
        for cell_id in execution_order:
            self.send_execution_started(cell_id)
            result = self.kernel.execute_cell(cell_id, self.cells[cell_id].code)
            self.send_result_to_frontend(cell_id, result)
    
    def find_downstream_cells(self, cell_id: str) -> set[str]:
        # BFS/DFS through dependency graph
        # Return all cells that directly or indirectly depend on cell_id
        pass
    
    def topological_sort(self, cell_ids: set[str]) -> list[str]:
        # Use Kahn's algorithm or DFS-based topological sort
        # Only sort the given subset, but use full graph for ordering
        # Return cells in valid execution order
        pass
    
    def has_cycle(self) -> bool:
        # Detect cycles using DFS with visited/in-progress sets
        pass
```

**Key Points:**
- **Rebuild dependency graph** on every cell update (code changes may alter dependencies)
- Only re-run cells that are affected by the change
- Maintain correct execution order (dependencies before dependents)
- **Detect circular dependencies** before execution and show helpful error
- **Send execution_started** before each cell runs (for live UI updates)

---

### 4. WebSocket Communication Protocol

**Purpose:** Real-time bidirectional communication between frontend and backend.

**Message Types (Frontend → Backend):**
```typescript
// User edits a cell
{
  type: "cell_updated",
  cell_id: "cell-123",
  code: "x = 5\nprint(x)"
}

// User manually triggers execution
{
  type: "execute_cell",
  cell_id: "cell-123"
}

// Add new cell
{
  type: "add_cell",
  position: 2
}

// Delete cell
{
  type: "delete_cell",
  cell_id: "cell-123"
}
```

**Message Types (Backend → Frontend):**
```typescript
// Initial state when client connects
{
  type: "notebook_state",
  cells: [
    { id: "cell-123", code: "x = 5", output: "5\n", error: "", status: "success" },
    { id: "cell-456", code: "print(x)", output: "5\n", error: "", status: "success" }
  ]
}

// Cell added confirmation
{
  type: "cell_added",
  cell: { id: "cell-789", code: "", output: "", error: "", status: "idle" },
  position: 2
}

// Cell deleted confirmation
{
  type: "cell_deleted",
  cell_id: "cell-123"
}

// Cell execution started
{
  type: "execution_started",
  cell_id: "cell-123"
}

// Cell execution completed
{
  type: "execution_result",
  cell_id: "cell-123",
  status: "success",
  output: "5\n",
  error: ""
}

// Multiple cells queued
{
  type: "execution_queue",
  cell_ids: ["cell-123", "cell-456", "cell-789"]
}
```

---

### 5. Frontend Cell Component

**Purpose:** Interactive code editor with execution state visualization and reactive updates.

**Requirements:**
- Display code editor (Monaco Editor) for editing cell code
- Show execution status indicators (idle/running/success/error) with visual feedback
- Display cell outputs (text, numbers, DataFrames as text) below code editor
- Display errors in red or distinct error styling
- Update outputs live as cells complete execution
- Show loading/running state for cells being executed

**React Component Structure:**
```typescript
interface Cell {
  id: string;
  code: string;
  output: string;
  error: string;
  status: 'idle' | 'running' | 'success' | 'error';
}

function NotebookCell({ cell, onChange, onDelete }: Props) {
  return (
    <div className="cell">
      <div className="cell-header">
        <span className="cell-id">Cell {cell.id}</span>
        <StatusIndicator status={cell.status} /> {/* Visual feedback */}
        <button onClick={() => onDelete(cell.id)}>Delete</button>
      </div>
      
      <MonacoEditor
        value={cell.code}
        onChange={(newCode) => onChange(cell.id, newCode)} // Auto-triggers reactive update
        language="python"
      />
      
      <div className="cell-output">
        {cell.status === 'running' && <div className="loading">Running...</div>}
        {cell.output && <pre>{cell.output}</pre>}
        {cell.error && <pre className="error">{cell.error}</pre>}
      </div>
    </div>
  );
}
```

**State Management:**
```typescript
function Notebook() {
  const [cells, setCells] = useState<Cell[]>([]);
  const ws = useRef<WebSocket | null>(null);
  const debounceTimers = useRef<Map<string, NodeJS.Timeout>>(new Map());
  
  useEffect(() => {
    // Connect to WebSocket
    ws.current = new WebSocket('ws://localhost:8000/ws');
    
    ws.current.onmessage = (event) => {
      const message = JSON.parse(event.data);
      handleBackendMessage(message); // Handle notebook_state, execution_result, etc.
    };
    
    return () => ws.current?.close();
  }, []);
  
  const handleCellChange = (cellId: string, newCode: string) => {
    // Update local state immediately (optimistic UI)
    setCells(cells.map(c => 
      c.id === cellId ? { ...c, code: newCode } : c
    ));
    
    // Debounce: wait 500ms after typing stops before sending to backend
    const existingTimer = debounceTimers.current.get(cellId);
    if (existingTimer) clearTimeout(existingTimer);
    
    debounceTimers.current.set(cellId, setTimeout(() => {
      ws.current?.send(JSON.stringify({
        type: 'cell_updated',
        cell_id: cellId,
        code: newCode
      }));
    }, 500));
  };
  
  const handleBackendMessage = (message: any) => {
    switch (message.type) {
      case 'notebook_state':
        setCells(message.cells);
        break;
      case 'execution_started':
        setCells(prev => prev.map(c => 
          c.id === message.cell_id ? { ...c, status: 'running' } : c
        ));
        break;
      case 'execution_result':
        setCells(prev => prev.map(c => 
          c.id === message.cell_id 
            ? { ...c, status: message.status, output: message.output, error: message.error }
            : c
        ));
        break;
      // ... handle cell_added, cell_deleted, execution_queue
    }
  };
}
```

---

## Implementation Steps (2-3 Days)

### Day 1: Backend Foundation
**Morning (3-4 hours):**
1. Set up FastAPI project with WebSocket endpoint
2. Implement `DependencyAnalyzer` class with AST parsing
3. Write unit tests for dependency detection (5-6 test cases)

**Afternoon (3-4 hours):**
4. Implement `NotebookKernel` with `exec()` and output capture
5. Test code execution with various Python snippets
6. Implement basic dependency graph builder

### Day 2: Reactive Engine + Frontend
**Morning (3-4 hours):**
7. Implement `ReactiveEngine` with topological sort
8. Wire up WebSocket message handlers
9. Test reactive re-execution with mock cells

**Afternoon (3-4 hours):**
10. Set up React project with TypeScript
11. Integrate Monaco Editor for cell code editing
12. Implement WebSocket client and message handling
13. Build basic cell UI component with:
    - Code editor (Monaco)
    - Execution status indicators (idle/running/success/error)
    - Output display area
    - Delete cell button

### Day 3: Integration + Polish
**Morning (2-3 hours):**
14. Connect frontend to backend WebSocket
15. Test end-to-end reactive execution flow
16. Debug any race conditions or state issues

**Afternoon (2-3 hours):**
17. Add cell management functionality:
    - Add new cells (button + keyboard shortcut)
    - Delete cells with proper cleanup
    - Edit cell code with Monaco Editor
18. Implement notebook save/load (JSON file)
19. Ensure visual indicators for execution status are working correctly
20. Test reactive updates (automatic downstream execution, live output updates)
21. Polish UI and fix edge cases (ensure no crashes, glitches, or incorrect logic)

---

## File Structure

```
reactive-notebook/
├── backend/
│   ├── main.py              # FastAPI app + WebSocket endpoint
│   ├── dependency.py        # DependencyAnalyzer
│   ├── kernel.py            # NotebookKernel
│   ├── reactive.py          # ReactiveEngine
│   └── models.py            # Pydantic models for messages
│
├── frontend/
│   ├── src/
│   │   ├── App.tsx          # Main notebook component
│   │   ├── Cell.tsx         # Individual cell component
│   │   ├── websocket.ts     # WebSocket client utilities
│   │   └── types.ts         # TypeScript interfaces
│   ├── package.json
│   └── tsconfig.json
│
├── notebooks/
│   └── default.json         # Persisted notebook data
│
├── requirements.txt
└── README.md
```

---

## MVP Limitations & Trade-offs

**Intentional Simplifications:**
- ✅ No authentication → Single user, local only
- ✅ No sandboxing → Trust the user, risk of infinite loops/crashes
- ✅ JSON file storage → Simple persistence, no database needed
- ✅ Text-only output → Simple rendering, no matplotlib/HTML/images
- ✅ Blocking execution → One cell at a time, simpler logic
- ✅ No version history → Can't undo/rollback changes
- ✅ No collaboration → No operational transform or CRDTs

**Known Issues:**
- ⚠️ Infinite loop will hang the server (need manual restart)
- ⚠️ Large output will slow down WebSocket (no pagination)
- ⚠️ Deleting a cell doesn't clean up its variables from namespace
- ⚠️ Re-running cells can cause side effects (file writes, network calls)

---

## Testing Strategy

**Backend Unit Tests:**
- Dependency detection with various Python syntax
- Topological sort with different graph structures
- Circular dependency detection
- Code execution with exceptions

**Integration Tests:**
- WebSocket message flow
- End-to-end reactive execution
- Cell add/delete with dependency updates

**Manual Testing Scenarios:**
1. Create cells: `a=1`, `b=a+1`, `c=b*2` → Verify all run in order
2. Edit first cell to `a=10` → Verify b and c re-run automatically
3. Create circular dependency: `a=b`, `b=a` → Verify error message
4. Delete middle cell → Verify downstream cell shows error
5. Create cell with print statement → Verify output appears
6. Create cell with syntax error → Verify error is caught and displayed

---

## Success Criteria

MVP is complete when:
- ✅ **Cell Management**: User can add, edit, and delete cells
- ✅ **Code Execution**: Running a cell generates its output (or error)
- ✅ **Visual Feedback**: Execution status indicators show idle/running/success/error states
- ✅ **Output Display**: Output (stdout) appears below each cell; errors displayed in red
- ✅ **Reactive Updates**: User can edit any cell and see dependent cells automatically re-run
- ✅ **Live Updates**: Outputs update in real-time as cells complete execution
- ✅ **Execution Order**: Execution order respects dependencies (topological sort)
- ✅ **Error Handling**: Circular dependencies show helpful error messages
- ✅ **Persistence**: Notebook persists to disk and reloads on server restart
- ✅ **Quality**: App is free of crashes, glitches, and incorrect business logic

**Demo Video Script:**
1. Start server, open browser to localhost:8000
2. Create cell 1: `name = "Alice"` → Run
3. Create cell 2: `greeting = f"Hello, {name}!"` → Runs automatically
4. Create cell 3: `print(greeting)` → Shows "Hello, Alice!"
5. Edit cell 1 to `name = "Bob"` → Cell 2 and 3 re-run, shows "Hello, Bob!"
6. Refresh page → Notebook state is preserved

---

## Quick Start Commands

```bash
# Backend setup
cd backend
python -m venv venv
source venv/bin/activate  # or venv\Scripts\activate on Windows
pip install fastapi uvicorn websockets
uvicorn main:app --reload

# Frontend setup (separate terminal)
cd frontend
npm install
npm run dev

# Open browser to http://localhost:5173 (Vite default)
```

**Minimal Dependencies:**
- Backend: `fastapi`, `uvicorn`, `websockets` (3 packages)
- Frontend: `react`, `react-dom`, `@monaco-editor/react`, `vite` (4 packages)

**Total MVP Size:** ~500 lines Python, ~300 lines TypeScript
